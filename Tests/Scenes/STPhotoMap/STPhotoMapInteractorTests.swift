//
//  STPhotoMapInteractorTests.swift
//  STPhotoMap
//
//  Created by Dimitri Strauneanu on 12/04/2019.
//  Copyright (c) 2019 mikelanza. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import STPhotoMap
import XCTest
import MapKit
import STPhotoCore

class STPhotoMapInteractorTests: XCTestCase {
    var sut: STPhotoMapInteractor!
    var presenterSpy: STPhotoMapPresentationLogicSpy!
    var workerSpy: STPhotoMapWorkerSpy!
    var currentUserLocationHandlerSpy: STPhotoMapCurrentUserLocationHandlerSpy!
    
    var workerDelay: Double = 0.1
    var delay: Double = 0.05
  
    // MARK: - Test lifecycle
  
    override func setUp() {
        super.setUp()
        self.setupSTPhotoMapInteractor()
    }
  
    override func tearDown() {
        super.tearDown()
    }
  
    // MARK: - Test setup
  
    func setupSTPhotoMapInteractor() {
        self.sut = STPhotoMapInteractor()
        
        self.presenterSpy = STPhotoMapPresentationLogicSpy()
        self.sut.presenter = self.presenterSpy
        
        self.workerSpy = STPhotoMapWorkerSpy(delegate: self.sut)
        self.sut.worker = self.workerSpy
        
        self.currentUserLocationHandlerSpy = STPhotoMapCurrentUserLocationHandlerSpy()
        self.currentUserLocationHandlerSpy.delegate = self.sut
        self.sut.currentUserLocationHandler = self.currentUserLocationHandlerSpy
    }
    
    private func waitForSynchronization() {
        let waitExpectation = expectation(description: "Waiting for the synchronization.")
        let queue = DispatchQueue(label: "queue", attributes: .concurrent)
        queue.async {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    private func waitForWorker(delay: Double) {
        let waitExpectation = expectation(description: "Waiting for the worker.")
        let queue = DispatchQueue.global()
        queue.asyncAfter(deadline: .now() + delay) {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    private func wait(delay: Double) {
        let waitExpectation = expectation(description: "Waiting.")
        let queue = DispatchQueue.global()
        queue.asyncAfter(deadline: .now() + delay) {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    // MARK: - Tests
      
    func testShouldUpdateVisibleTiles() {
        let tiles: [TileCoordinate] = STPhotoMapSeeds.tileCoordinates

        let request = STPhotoMapModels.VisibleTiles.Request(tiles: tiles)
        self.sut.shouldUpdateVisibleTiles(request: request)

        XCTAssertEqual(self.sut.visibleTiles.count, tiles.count)
    }
    
    func testShouldUpdateVisibleMapRect() {
        let mapRect = MKMapRect.init(origin: MKMapPoint(STPhotoMapSeeds.coordinate), size: MKMapSize(width: 100, height: 100))
        
        let request = STPhotoMapModels.VisibleMapRect.Request(mapRect: mapRect)
        self.sut.shouldUpdateVisibleMapRect(request: request)
    
        XCTAssertEqual(self.sut.visibleMapRect.height, mapRect.height)
        XCTAssertEqual(self.sut.visibleMapRect.width, mapRect.width)
        XCTAssertEqual(self.sut.visibleMapRect.origin.x, mapRect.origin.x)
        XCTAssertEqual(self.sut.visibleMapRect.origin.y, mapRect.origin.y)
    }
    
    func testShouldUpdateSelectedPhotoAnnotation() {
        let annotations = STPhotoMapSeeds().photoAnnotations()
        self.sut.selectedPhotoAnnotation = annotations.first
        
        let request = STPhotoMapModels.SelectedPhotoAnnotation.Request(annotation: annotations.last)
        self.sut.shouldUpdateSelectedPhotoAnnotation(request: request)
        
        XCTAssertEqual(self.sut.selectedPhotoAnnotation, annotations.last)
    }
    
    // MARK: - Navigation tests
    
    func testShouldNavigateToPhotoDetails() {
        let request = STPhotoMapModels.PhotoDetailsNavigation.Request(photoId: STPhotoMapSeeds.photoId)
        self.sut.shouldNavigateToPhotoDetails(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldNavigateToPhotoCollection() {
        let request = STPhotoMapModels.PhotoCollectionNavigation.Request(location: STPhotoMapSeeds.location, entityLevel: EntityLevel.block)
        self.sut.shouldNavigateToPhotoCollection(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoCollectionCalled)
    }

    // MARK: - Download image for photo annotation

    func testShouldDownloadImageForPhotoAnnotationWhenThereIsNoImageForSuccessCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.image = UIImage()

        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)

        XCTAssertNil(photoAnnotation.image)
        XCTAssertTrue(photoAnnotation.isLoading)
        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertFalse(photoAnnotation.isLoading)
        XCTAssertNotNil(photoAnnotation.image)
    }

    func testShouldDownloadImageForPhotoAnnotationWhenThereIsNoImageForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetImageForPhotoAnnotation = true

        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)

        XCTAssertNil(photoAnnotation.image)
        XCTAssertTrue(photoAnnotation.isLoading)
        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertFalse(photoAnnotation.isLoading)
        XCTAssertNil(photoAnnotation.image)
    }

    func testShouldDownloadImageForPhotoAnnotationWhenThereIsAnImage() {
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)

        XCTAssertFalse(self.workerSpy.getImageForPhotoAnnotationCalled)
    }

    // MARK: - Entity level

    func testShouldDetermineEntityLevelWhenCacheIsEmptyAndThereAreNoActiveDownloadsForSuccessCase() {
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        self.workerSpy.geoEntity = geoEntity
        self.workerSpy.image = UIImage()
        
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect()

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }

    func testShouldDetermineEntityLevelWhenCacheIsEmptyAndThereAreNoActiveDownloadsForFailureCase() {
        self.workerSpy.shouldFailGetGeojsonTileForEntityLevel = true

        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenCacheIsEmptyAndThereAreActiveDownloads() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl

        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.addActiveDownload(keyUrl)
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenCacheIsNotEmptyAndNoActiveDownloads() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        
        self.workerSpy.geoEntity = geoEntity
        self.workerSpy.image = UIImage()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect()

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeojsonTileForCachingCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
        
        self.wait(delay: self.delay)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }

    func testShouldDetermineEntityLevelWhenNewEntityLevelIsNotChanged() {
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.entityLevel = .city
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenNewEntityLevelIsChanged() {
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        self.workerSpy.geoEntity = geoEntity
        self.workerSpy.image = UIImage()
        
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.entityLevel = .unknown
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect()

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineEntityLevelWhenEntityLevelIsChangedShouldAskTheInteractorToResetCurrentCarousel() {
        let carousel = STCarousel()
        carousel.entityId = 100
        carousel.entityLevel = .block
        self.sut.carouselHandler.carousel = carousel
        
        self.sut.photoMapEntityLevelHandler(newEntityLevel: EntityLevel.country)
        
        XCTAssertEqual(self.sut.carouselHandler.carousel.entityId, STCarousel().entityId)
        XCTAssertEqual(self.sut.carouselHandler.carousel.entityLevel, STCarousel().entityLevel)
    }
    
    func testShouldDetermineEntityLevelWhenNewEntityLevelIsLocation() throws {
        workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        workerSpy.photo = STPhotoMapSeeds().photo()
        
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.entityLevel = .unknown
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect()

        self.sut.cacheHandler.removeAllActiveDownloads()

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertFalse(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeoEntityForEntityCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertFalse(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)

        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }

    func testShouldDetermineEntityLevelWhenDownloadedTileIsNotStillVisible() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineEntityLevel()
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.visibleTiles.removeAll()
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
    }

    func testShouldDetermineEntityLevelWhenDownloadedTileIsStillVisible() {
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        self.workerSpy.geoEntity = geoEntity
        self.workerSpy.image = UIImage()
        
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect()

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonEntityLevelOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }

    // MARK: - Location level

    func testShouldDetermineLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()

        self.workerSpy.geojsonObject = geojsonObject
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsNotLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .city

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAndThereAreActiveDownloads() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.locationLevelHandler.addActiveDownload(keyUrl)

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertFalse(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAfterTileIsDownloadedForSuccessCase() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate

        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsEmptyAndEntityLevelIsNotLocationAfterTileDownload() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        self.sut.entityLevelHandler.entityLevel = .city

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertFalse(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertFalse(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldRemoveLocationAnnotationWhenEntityLevelIsNotLocation() {
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        
        self.sut.entityLevelHandler.entityLevel = .unknown
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineEntityLevel()
        
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
    }
    
    // MARK: - Photo annotation selection
    
    func testShouldSelectPhotoAnnotationWhenItIsAlreadySelected() {
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        
        annotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetPhotoDetailsForPhotoAnnotation = true
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsNotLocation() {
        self.sut.entityLevelHandler.entityLevel = .block
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertFalse(annotation.isSelected)
        XCTAssertTrue(previousAnnotation.isSelected)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelWillChangeForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    // MARK: - Photo cluster annotation inflation
    
    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsMaximumAndThereAreOver15ClusterPhotos() {
        let zoomLevel = 20

        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 20)
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.presenterSpy.presentNavigateToSpecificPhotosCalled)
    }
    
    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsMaximumAndThereAreUnder15ClusterPhotosWithTheSameLocation() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.image = UIImage()
        let zoomLevel = 20

        let clusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        clusterAnnotation.interface = clusterAnnotationInterfaceSpy

        let previousClusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)
        previousClusterAnnotation.interface = previousClusterAnnotationInterfaceSpy

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)

        XCTAssertTrue(previousClusterAnnotationInterfaceSpy.deflateCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.inflateCalled)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertTrue(value.isLoading)
            XCTAssertNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)

        self.waitForWorker(delay: self.workerDelay)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertFalse(value.isLoading)
            XCTAssertNotNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setImageCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)
    }

    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsNotMaximumAndThereAreUnder15ClusterPhotosWithTheSameLocation() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.image = UIImage()
        let zoomLevel = 17

        let clusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        clusterAnnotation.interface = clusterAnnotationInterfaceSpy

        let previousClusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)
        previousClusterAnnotation.interface = previousClusterAnnotationInterfaceSpy

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)

        XCTAssertTrue(previousClusterAnnotationInterfaceSpy.deflateCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.inflateCalled)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertTrue(value.isLoading)
            XCTAssertNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)

        self.waitForWorker(delay: self.workerDelay)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertFalse(value.isLoading)
            XCTAssertNotNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setImageCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)
    }

    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsNotMaximumAndClusterPhotosWithDifferentLocation() {
        let zoomLevel = 17

        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10, sameCoordinate: false)
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.presenterSpy.presentZoomToCoordinateCalled)
    }
    
    // MARK: - Photo cluster annotation selection
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsAlreadySelected() {
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        annotation.isSelected = true
        
        let previousAnnotation = annotations.last!
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetPhotoDetailsForPhotoAnnotation = true
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsNotLocation() {
        self.sut.entityLevelHandler.entityLevel = .block
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertFalse(annotation.isSelected)
        XCTAssertTrue(previousAnnotation.isSelected)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelWillChangeForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    // MARK: - Carousel selection
    
    func testShouldSelectCarouselWhenCacheIsNotEmptyForSuccessCase() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.workerSpy.image = UIImage()
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsNotEmptyForFailureCase() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetGeoEntityForEntity = true
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsEmptyForSuccessCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        self.workerSpy.geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.workerSpy.image = UIImage()
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselSelectionOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselSelectionCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
        
        XCTAssertEqual(self.presenterSpy.presentLoadingStateCalledCount, 2)
        XCTAssertEqual(self.presenterSpy.presentNotLoadingStateCalledCount, 2)
    }
    
    func testShouldSelectCarouselWhenCacheIsEmptyForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetGeojsonTileForCarouselSelection = true
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselSelectionOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselSelectionCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    // MARK: - Carousel determination
    
    func testShouldDetermineCarouselWhenEntityLevelIsLocation() throws {
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.workerSpy.delay = self.workerDelay
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = MKMapRect(origin: MKMapPoint(coordinate), size: MKMapSize.init(width: 1000, height: 1000))
        
        self.sut.shouldDetermineCarousel()
        
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineCarouselWhenActualCarouselShouldNotBeChanged() throws {
        self.workerSpy.delay = self.workerDelay
        
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.sut.carouselHandler.updateCarouselFor(geoEntity: geoEntity)
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect()
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineCarousel()
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineCarouselWhenActualCarouselShouldBeChanged() throws {
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.sut.carouselHandler.updateCarouselFor(geoEntity: geoEntity)
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geoEntity = geoEntity
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect().offsetBy(dx: 10000, dy: 10000)
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineCarousel()
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineCarouselWhenCacheIsEmptyAndThereAreActiveDownloads() throws {
        self.workerSpy.delay = self.workerDelay
        
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.sut.carouselHandler.updateCarouselFor(geoEntity: geoEntity)
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.carouselHandler.addActiveDownload(keyUrl)
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect().offsetBy(dx: 10000, dy: 10000)
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineCarousel()
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeoEntityForEntityCalled)
        XCTAssertFalse(self.workerSpy.getGeojsonTileForCarouselDeterminationCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineCarouselWhenCacheIsEmptyAndThereAreNoActiveDownloadsAndFeatureDoesNotFulfillOverlapConditions() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        let geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        let geojsonObjectMapRect = geojsonObject.objectBoundingBox!.mapRect()
        let visibleMapRect = geojsonObjectMapRect.offsetBy(dx: geojsonObjectMapRect.maxX, dy: geojsonObjectMapRect.maxY)
        self.sut.visibleMapRect = visibleMapRect
        
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = geojsonObject
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineCarousel()
        
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselDeterminationCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertFalse(self.workerSpy.cancelAllGeojsonCarouselDeterminationOperationsCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineCarouselWhenCacheIsEmptyAndThereAreNoActiveDownloadsAndFeatureFulfillsOverlapConditions() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        self.workerSpy.geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.workerSpy.image = UIImage()
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = try! STPhotoMapSeeds().geojsonObject().objectBoundingBox!.mapRect()
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineCarousel()
    
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselDeterminationCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselDeterminationOperationsCalled)
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    // MARK: - Carousel reloading
    
    func testShouldReloadCarouselWhenEntityLevelIsLocation() {
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.workerSpy.delay = self.workerDelay
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = MKMapRect(origin: MKMapPoint(coordinate), size: MKMapSize.init(width: 1000, height: 1000))
        
        self.sut.shouldReloadCarousel()
        
        let carousel = self.sut.carouselHandler.carousel
        XCTAssertEqual(carousel.entityId, -1)
        XCTAssertEqual(carousel.entityLevel, .unknown)
        XCTAssertNil(carousel.currentPhoto)
        XCTAssertEqual(carousel.name, "")
        XCTAssertEqual(carousel.overlays.count, 0)
        XCTAssertEqual(carousel.photoCount, 0)
        XCTAssertEqual(carousel.photos.count, 0)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldReloadCarouselWhenCacheIsNotEmptyAndCurrentCarouselShouldBeChanged() {
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.sut.carouselHandler.updateCarouselFor(geoEntity: geoEntity)
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geoEntity = geoEntity
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.visibleMapRect = geoEntity.boundingBox.mapRect().offsetBy(dx: 10000, dy: 10000)
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadCarousel()
        
        let carousel = self.sut.carouselHandler.carousel
        XCTAssertEqual(carousel.entityId, -1)
        XCTAssertEqual(carousel.entityLevel, .unknown)
        XCTAssertNil(carousel.currentPhoto)
        XCTAssertEqual(carousel.name, "")
        XCTAssertEqual(carousel.overlays.count, 0)
        XCTAssertEqual(carousel.photoCount, 0)
        XCTAssertEqual(carousel.photos.count, 0)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldReloadCarouselWhenCacheIsEmptyAndThereAreNoActiveDownloadsAndFeatureDoesNotFulfillOverlapConditions() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        let geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        let geojsonObjectMapRect = geojsonObject.objectBoundingBox!.mapRect()
        let visibleMapRect = geojsonObjectMapRect.offsetBy(dx: geojsonObjectMapRect.maxX, dy: geojsonObjectMapRect.maxY)
        self.sut.visibleMapRect = visibleMapRect
        
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = geojsonObject
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadCarousel()
        
        let carousel = self.sut.carouselHandler.carousel
        XCTAssertEqual(carousel.entityId, -1)
        XCTAssertEqual(carousel.entityLevel, .unknown)
        XCTAssertNil(carousel.currentPhoto)
        XCTAssertEqual(carousel.name, "")
        XCTAssertEqual(carousel.overlays.count, 0)
        XCTAssertEqual(carousel.photoCount, 0)
        XCTAssertEqual(carousel.photos.count, 0)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselDeterminationCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertFalse(self.workerSpy.cancelAllGeojsonCarouselDeterminationOperationsCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertFalse(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldReloadCarouselWhenCacheIsEmptyAndThereAreActiveDownloadsAndFeatureFulfillsOverlapConditions() {
        let geoEntity = try! STPhotoMapSeeds().geoEntity()
        let geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = geojsonObject
        self.workerSpy.geoEntity = geoEntity
        self.workerSpy.image = UIImage()
        
        self.sut.carouselHandler.updateCarouselFor(geoEntity: geoEntity)
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        self.sut.carouselHandler.addActiveDownload(keyUrl)
        self.sut.visibleMapRect = geojsonObject.objectBoundingBox!.mapRect()
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadCarousel()
        
        let carousel = self.sut.carouselHandler.carousel
        XCTAssertEqual(carousel.entityId, -1)
        XCTAssertEqual(carousel.entityLevel, .unknown)
        XCTAssertNil(carousel.currentPhoto)
        XCTAssertEqual(carousel.name, "")
        XCTAssertEqual(carousel.overlays.count, 0)
        XCTAssertEqual(carousel.photoCount, 0)
        XCTAssertEqual(carousel.photos.count, 0)
                
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselDeterminationCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselDeterminationOperationsCalled)
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    // MARK: - Photo annotation determination
    
    func testShouldDetermineSelectedPhotoAnnotationWhenEntityLevelIsNotLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineSelectedPhotoAnnotation()
        
        XCTAssertFalse(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertFalse(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldDetermineSelectedPhotoAnnotationWhenCurrentSelectedPhotoAnnotationIsVisibleOnScreen() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        let selectedPhotoAnnotation = STPhotoMapSeeds().photoAnnotations().first
        self.sut.selectedPhotoAnnotation = selectedPhotoAnnotation
        self.sut.visibleMapRect = MKMapRect(origin: MKMapPoint(selectedPhotoAnnotation!.coordinate), size: MKMapSize(width: 1000, height: 1000))
            
        self.waitForSynchronization()
        
        self.sut.shouldDetermineSelectedPhotoAnnotation()
        
        XCTAssertFalse(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertFalse(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldDetermineSelectedPhotoAnnotationWhenCurrentSelectedPhotoAnnotationIsNotVisibleOnScreenAndCacheIsNotEmpty() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        self.sut.selectedPhotoAnnotation = STPhotoMapSeeds().photoAnnotations().first
        self.sut.visibleMapRect = geojsonObject.objectBoundingBox!.mapRect()
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineSelectedPhotoAnnotation()
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldDetermineSelectedPhotoAnnotationWhenCurrentSelectedPhotoAnnotationIsNotVisibleOnScreenAndCacheIsEmpty() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        self.sut.selectedPhotoAnnotation = STPhotoMapSeeds().photoAnnotations().first
        self.sut.visibleMapRect = geojsonObject.objectBoundingBox!.mapRect()
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineSelectedPhotoAnnotation()
        
        XCTAssertFalse(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertFalse(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    // MARK: - Current user location
    
    func testShouldAskForLocationPermissionsWhenStatusIsAuthorizedAlways() {
        self.currentUserLocationHandlerSpy.status = .authorizedAlways
        
        self.sut.shouldAskForLocationPermissions()
        XCTAssertTrue(self.presenterSpy.presentCenterToCoordinateCalled)
    }
    
    func testShouldAskForLocationPermissionsWhenStatusIsAuthorizedWhenInUse() {
        self.currentUserLocationHandlerSpy.status = .authorizedWhenInUse
        
        self.sut.shouldAskForLocationPermissions()
        XCTAssertTrue(self.presenterSpy.presentCenterToCoordinateCalled)
    }
    
    func testShouldAskForLocationPermissionsWhenStatusIsNotDetermined() {
        self.currentUserLocationHandlerSpy.status = .notDetermined
        
        self.sut.shouldAskForLocationPermissions()
        XCTAssertTrue(self.currentUserLocationHandlerSpy.requestWhenInUseAuthorizationCalled)
    }
    
    func testShouldAskForLocationPermissionsWhenStatusIsDenied() {
        self.currentUserLocationHandlerSpy.status = .denied
        
        self.sut.shouldAskForLocationPermissions()
        XCTAssertTrue(self.presenterSpy.presentLocationAccessDeniedAlertCalled)
    }
    
    func testShouldAskForLocationPermissionsWhenChangingStatusForAuthorizedAlways() {
        self.sut.currentUserLocationHandler.locationManager(CLLocationManager(), didChangeAuthorization: CLAuthorizationStatus.authorizedAlways)
        XCTAssertTrue(self.presenterSpy.presentCenterToCoordinateCalled)
    }
    
    func testShouldAskForLocationPermissionsWhenChangingStatusForAuthorizedWhenInUse() {
         self.sut.currentUserLocationHandler.locationManager(CLLocationManager(), didChangeAuthorization: CLAuthorizationStatus.authorizedWhenInUse)
        XCTAssertTrue(self.presenterSpy.presentCenterToCoordinateCalled)
    }
    
    func testShouldAskForLocationPermissionsWhenLocationManagerDidUpdateLocations() {
        let locations = [CLLocation(latitude: STPhotoMapSeeds.coordinate.latitude, longitude: STPhotoMapSeeds.coordinate.longitude)]
        self.sut.currentUserLocationHandler.locationManager(CLLocationManager(), didUpdateLocations: locations)
        
        XCTAssertTrue(self.presenterSpy.presentCenterToCoordinateCalled)
        XCTAssertTrue(self.currentUserLocationHandlerSpy.didZoomToUserLocation)
    }
    
    func testShouldAskForLocationPermissionsWhenLocationManagerDidUpdateLocationsWhenItDidZoomToUserLocation() {
        self.currentUserLocationHandlerSpy.didZoomToUserLocation = true
        
        let locations = [CLLocation(latitude: STPhotoMapSeeds.coordinate.latitude, longitude: STPhotoMapSeeds.coordinate.longitude)]
        self.sut.currentUserLocationHandler.locationManager(CLLocationManager(), didUpdateLocations: locations)
        
        XCTAssertFalse(self.presenterSpy.presentCenterToCoordinateCalled)
        XCTAssertTrue(self.currentUserLocationHandlerSpy.didZoomToUserLocation)
    }
    
    func testShouldAskForLocationPermissionsWhenLocationManagerDidUpdateLocationsWhenThereAreNoLocations() {
        self.sut.currentUserLocationHandler.locationManager(CLLocationManager(), didUpdateLocations: [])
        XCTAssertFalse(self.presenterSpy.presentCenterToCoordinateCalled)
        XCTAssertFalse(self.currentUserLocationHandlerSpy.didZoomToUserLocation)
    }
    
    func testShouldOpenDataSourcesLink() {
        self.sut.shouldOpenDataSourcesLink()
        XCTAssertTrue(self.presenterSpy.presentOpenDataSourcesLinkCalled)
    }
    
    func testShouldOpenSettingsApplication() {
        self.sut.shouldOpenSettingsApplication()
        XCTAssertTrue(self.presenterSpy.presentOpenApplicationCalled)
    }
    
    // MARK: - Reload location level
    
    func testShouldReloadLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        
        self.workerSpy.geojsonObject = geojsonObject
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsNotLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .city
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertNil(self.sut.selectedPhotoAnnotation)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAndThereAreActiveDownloads() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.locationLevelHandler.addActiveDownload(keyUrl)
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertNil(self.sut.selectedPhotoAnnotation)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertFalse(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAfterTileIsDownloadedForSuccessCase() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsEmptyAndEntityLevelIsNotLocationAfterTileDownload() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertNil(self.sut.selectedPhotoAnnotation)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        self.sut.entityLevelHandler.entityLevel = .city
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertFalse(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertFalse(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
}
