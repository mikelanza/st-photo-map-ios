//
//  STPhotoMapInteractorTests.swift
//  STPhotoMap
//
//  Created by Dimitri Strauneanu on 12/04/2019.
//  Copyright (c) 2019 mikelanza. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import STPhotoMap
import XCTest
import MapKit
import STPhotoCore

class STPhotoMapInteractorTests: XCTestCase {
    var sut: STPhotoMapInteractor!
    var presenterSpy: STPhotoMapPresentationLogicSpy!
    var workerSpy: STPhotoMapWorkerSpy!
    var currentUserLocationHandlerSpy: STPhotoMapCurrentUserLocationHandlerSpy!
    
    var workerDelay: Double = 0.1
    var delay: Double = 0.05
  
    // MARK: - Test lifecycle
  
    override func setUp() {
        super.setUp()
        self.setupSTPhotoMapInteractor()
    }
  
    override func tearDown() {
        super.tearDown()
    }
  
    // MARK: - Test setup
  
    func setupSTPhotoMapInteractor() {
        self.sut = STPhotoMapInteractor()
        
        self.presenterSpy = STPhotoMapPresentationLogicSpy()
        self.sut.presenter = self.presenterSpy
        
        self.workerSpy = STPhotoMapWorkerSpy(delegate: self.sut)
        self.sut.worker = self.workerSpy
        
        self.currentUserLocationHandlerSpy = STPhotoMapCurrentUserLocationHandlerSpy()
        self.currentUserLocationHandlerSpy.delegate = self.sut
        self.sut.currentUserLocationHandler = self.currentUserLocationHandlerSpy
    }
    
    private func waitForSynchronization() {
        let waitExpectation = expectation(description: "Waiting for the synchronization.")
        let queue = DispatchQueue(label: "queue", attributes: .concurrent)
        queue.async {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    private func waitForWorker(delay: Double) {
        let waitExpectation = expectation(description: "Waiting for the worker.")
        let queue = DispatchQueue.global()
        queue.asyncAfter(deadline: .now() + delay) {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    private func wait(delay: Double) {
        let waitExpectation = expectation(description: "Waiting.")
        let queue = DispatchQueue.global()
        queue.asyncAfter(deadline: .now() + delay) {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    // MARK: - Tests
      
    func testShouldUpdateVisibleTiles() {
        let tiles: [TileCoordinate] = STPhotoMapSeeds.tileCoordinates

        let request = STPhotoMapModels.VisibleTiles.Request(tiles: tiles)
        self.sut.shouldUpdateVisibleTiles(request: request)

        XCTAssertEqual(self.sut.visibleTiles.count, tiles.count)
    }
    
    func testShouldUpdateVisibleMapRect() {
        let mapRect = MKMapRect.init(origin: MKMapPoint(STPhotoMapSeeds.coordinate), size: MKMapSize(width: 100, height: 100))
        
        let request = STPhotoMapModels.VisibleMapRect.Request(mapRect: mapRect)
        self.sut.shouldUpdateVisibleMapRect(request: request)
    
        XCTAssertEqual(self.sut.visibleMapRect.height, mapRect.height)
        XCTAssertEqual(self.sut.visibleMapRect.width, mapRect.width)
        XCTAssertEqual(self.sut.visibleMapRect.origin.x, mapRect.origin.x)
        XCTAssertEqual(self.sut.visibleMapRect.origin.y, mapRect.origin.y)
    }
    
    func testShouldUpdateSelectedPhotoAnnotation() {
        let annotations = STPhotoMapSeeds().photoAnnotations()
        self.sut.selectedPhotoAnnotation = annotations.first
        
        let request = STPhotoMapModels.SelectedPhotoAnnotation.Request(annotation: annotations.last)
        self.sut.shouldUpdateSelectedPhotoAnnotation(request: request)
        
        XCTAssertEqual(self.sut.selectedPhotoAnnotation, annotations.last)
    }
    
    func testShouldOpenDataSourcesLink() {
        self.sut.shouldOpenDataSourcesLink()
        XCTAssertTrue(self.presenterSpy.presentOpenDataSourcesLinkCalled)
    }
    
    func testShouldOpenSettingsApplication() {
        self.sut.shouldOpenSettingsApplication()
        XCTAssertTrue(self.presenterSpy.presentOpenApplicationCalled)
    }
    
    // MARK: - Navigation tests
    
    func testShouldNavigateToPhotoDetails() {
        let request = STPhotoMapModels.PhotoDetailsNavigation.Request(photoId: STPhotoMapSeeds.photoId)
        self.sut.shouldNavigateToPhotoDetails(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldNavigateToPhotoCollection() {
        let request = STPhotoMapModels.PhotoCollectionNavigation.Request(location: STPhotoMapSeeds.location, entityLevel: EntityLevel.block)
        self.sut.shouldNavigateToPhotoCollection(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoCollectionCalled)
    }

    // MARK: - Download image for photo annotation
    
    func testShouldDownloadImageForPhotoAnnotationShouldUpdateLoadingTrueForPhotoAnnotation() {
        self.workerSpy.delay = self.workerDelay
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        self.sut.shouldDownloadImageForPhotoAnnotation(request: STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation))
        XCTAssertTrue(photoAnnotation.isLoading)
    }
    
    func testShouldDownloadImageForPhotoAnnotationShouldUpdateLoadingFalseForPhotoAnnotation() {
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        self.sut.shouldDownloadImageForPhotoAnnotation(request: STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation))
        XCTAssertFalse(photoAnnotation.isLoading)
    }
    
    func testShouldDownloadImageForPhotoAnnotationShouldUpdateImageForPhotoAnnotation() {
        self.workerSpy.image = UIImage()
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        self.sut.shouldDownloadImageForPhotoAnnotation(request: STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation))
        XCTAssertNotNil(photoAnnotation.image)
    }
    
    func testShouldDownloadImageForPhotoAnnotationShouldAskTheWorkerToGetImageForPhotoAnnotation() {
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        self.sut.shouldDownloadImageForPhotoAnnotation(request: STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation))
        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)
    }
    
    func testShouldDownloadImageForPhotoAnnotationWhenThereIsAnImage() {
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)
        XCTAssertFalse(self.workerSpy.getImageForPhotoAnnotationCalled)
    }
    
    // MARK: - Photo annotation selection
    
    func testShouldSelectPhotoAnnotationWhenItIsAlreadySelected() {
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        
        annotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetPhotoDetailsForPhotoAnnotation = true
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsNotLocation() {
        self.sut.entityLevelHandler.entityLevel = .block
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertFalse(annotation.isSelected)
        XCTAssertTrue(previousAnnotation.isSelected)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelWillChangeForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    // MARK: - Photo cluster annotation inflation
    
    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsMaximumAndThereAreOver15ClusterPhotos() {
        let zoomLevel = 20

        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 20)
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.presenterSpy.presentNavigateToSpecificPhotosCalled)
    }
    
    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsMaximumAndThereAreUnder15ClusterPhotosWithTheSameLocation() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.image = UIImage()
        let zoomLevel = 20

        let clusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        clusterAnnotation.interface = clusterAnnotationInterfaceSpy

        let previousClusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)
        previousClusterAnnotation.interface = previousClusterAnnotationInterfaceSpy

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)

        XCTAssertTrue(previousClusterAnnotationInterfaceSpy.deflateCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.inflateCalled)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertTrue(value.isLoading)
            XCTAssertNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)

        self.waitForWorker(delay: self.workerDelay)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertFalse(value.isLoading)
            XCTAssertNotNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setImageCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)
    }

    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsNotMaximumAndThereAreUnder15ClusterPhotosWithTheSameLocation() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.image = UIImage()
        let zoomLevel = 17

        let clusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        clusterAnnotation.interface = clusterAnnotationInterfaceSpy

        let previousClusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)
        previousClusterAnnotation.interface = previousClusterAnnotationInterfaceSpy

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.workerSpy.getImageForPhotoAnnotationCalled)

        XCTAssertTrue(previousClusterAnnotationInterfaceSpy.deflateCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.inflateCalled)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertTrue(value.isLoading)
            XCTAssertNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)

        self.waitForWorker(delay: self.workerDelay)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertFalse(value.isLoading)
            XCTAssertNotNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setImageCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)
    }

    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsNotMaximumAndClusterPhotosWithDifferentLocation() {
        let zoomLevel = 17

        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10, sameCoordinate: false)
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.presenterSpy.presentZoomToCoordinateCalled)
    }
    
    // MARK: - Photo cluster annotation selection
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsAlreadySelected() {
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        annotation.isSelected = true
        
        let previousAnnotation = annotations.last!
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetPhotoDetailsForPhotoAnnotation = true
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsNotLocation() {
        self.sut.entityLevelHandler.entityLevel = .block
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertFalse(annotation.isSelected)
        XCTAssertTrue(previousAnnotation.isSelected)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelWillChangeForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    // MARK: - Carousel selection
    
    func testShouldSelectCarouselWhenCacheIsNotEmptyForSuccessCase() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.workerSpy.image = UIImage()
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsNotEmptyForFailureCase() throws {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetGeoEntityForEntity = true
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsEmptyForSuccessCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().geojsonObject()
        self.workerSpy.geoEntity = try! STPhotoMapSeeds().geoEntity()
        self.workerSpy.image = UIImage()
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselSelectionOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselSelectionCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
        
        XCTAssertEqual(self.presenterSpy.presentLoadingStateCalledCount, 2)
        XCTAssertEqual(self.presenterSpy.presentNotLoadingStateCalledCount, 2)
    }
    
    func testShouldSelectCarouselWhenCacheIsEmptyForFailureCase() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.shouldFailGetGeojsonTileForCarouselSelection = true
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselSelectionOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselSelectionCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    // MARK: - Reload location level
    
    func testShouldReloadLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        
        self.workerSpy.geojsonObject = geojsonObject
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsNotLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapGeojsonCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .city
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertNil(self.sut.selectedPhotoAnnotation)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAndThereAreActiveDownloads() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.locationLevelHandler.addActiveDownload(keyUrl)
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertNil(self.sut.selectedPhotoAnnotation)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertFalse(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAfterTileIsDownloadedForSuccessCase() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentNewSelectedPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldReloadLocationLevelWhenCacheIsEmptyAndEntityLevelIsNotLocationAfterTileDownload() {
        self.workerSpy.delay = self.workerDelay
        self.workerSpy.geojsonObject = try! STPhotoMapSeeds().locationGeojsonObject()
        self.workerSpy.photo = STPhotoMapSeeds().photo()
        
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.waitForSynchronization()
        
        self.sut.shouldReloadLocationLevel()
        
        XCTAssertNil(self.sut.selectedPhotoAnnotation)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationOverlayCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
        
        self.sut.entityLevelHandler.entityLevel = .city
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
        
        XCTAssertFalse(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertFalse(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
}
