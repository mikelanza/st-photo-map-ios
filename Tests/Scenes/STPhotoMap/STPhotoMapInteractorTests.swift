//
//  STPhotoMapInteractorTests.swift
//  STPhotoMap
//
//  Created by Dimitri Strauneanu on 12/04/2019.
//  Copyright (c) 2019 mikelanza. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import STPhotoMap
import XCTest
import MapKit

class STPhotoMapInteractorTests: XCTestCase {
    var sut: STPhotoMapInteractor!
    var presenterSpy: STPhotoMapPresentationLogicSpy!
    var workerSpy: STPhotoMapWorkerSuccessSpy!
    
    var workerDelay: Double = 0.1
    var delay: Double = 0.05
  
    // MARK: - Test lifecycle
  
    override func setUp() {
        super.setUp()
        self.setupSTPhotoMapInteractor()
    }
  
    override func tearDown() {
        super.tearDown()
    }
  
    // MARK: - Test setup
  
    func setupSTPhotoMapInteractor() {
        self.sut = STPhotoMapInteractor()
        
        self.presenterSpy = STPhotoMapPresentationLogicSpy()
        self.sut.presenter = self.presenterSpy
        
        self.workerSpy = STPhotoMapWorkerSuccessSpy(delegate: self.sut)
        self.sut.worker = self.workerSpy
    }
    
    private func waitForSynchronization() {
        let waitExpectation = expectation(description: "Waiting for the synchronization.")
        let queue = DispatchQueue(label: "queue", attributes: .concurrent)
        queue.async {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    private func waitForWorker(delay: Double) {
        let waitExpectation = expectation(description: "Waiting for the worker.")
        let queue = DispatchQueue.global()
        queue.asyncAfter(deadline: .now() + delay) {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    private func wait(delay: Double) {
        let waitExpectation = expectation(description: "Waiting.")
        let queue = DispatchQueue.global()
        queue.asyncAfter(deadline: .now() + delay) {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    // MARK: - Tests
      
    func testShouldUpdateVisibleTiles() {
        let tiles: [TileCoordinate] = STPhotoMapSeeds.tileCoordinates

        let request = STPhotoMapModels.VisibleTiles.Request(tiles: tiles)
        self.sut.shouldUpdateVisibleTiles(request: request)

        XCTAssertEqual(self.sut.visibleTiles.count, tiles.count)
    }
    
    // MARK: - Navigation tests
    
    func testShouldNavigateToPhotoDetails() {
        let request = STPhotoMapModels.PhotoDetailsNavigation.Request(photoId: STPhotoMapSeeds.photoId)
        self.sut.shouldNavigateToPhotoDetails(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldNavigateToPhotoCollection() {
        let request = STPhotoMapModels.PhotoCollectionNavigation.Request(location: STPhotoMapSeeds.location, entityLevel: EntityLevel.block)
        self.sut.shouldNavigateToPhotoCollection(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoCollectionCalled)
    }

    // MARK: - Download image for photo annotation

    func testShouldDownloadImageForPhotoAnnotationWhenThereIsNoImageForSuccessCase() {
        self.workerSpy.delay = self.workerDelay

        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)

        XCTAssertNil(photoAnnotation.image)
        XCTAssertTrue(photoAnnotation.isLoading)
        XCTAssertTrue(self.workerSpy.downloadImageForPhotoAnnotationCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertFalse(photoAnnotation.isLoading)
        XCTAssertNotNil(photoAnnotation.image)
    }

    func testShouldDownloadImageForPhotoAnnotationWhenThereIsNoImageForFailureCase() {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        worker.delay = self.workerDelay
        self.sut.worker = worker

        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        photoAnnotation.image = nil
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)

        XCTAssertNil(photoAnnotation.image)
        XCTAssertTrue(photoAnnotation.isLoading)
        XCTAssertTrue(worker.downloadImageForPhotoAnnotationCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertFalse(photoAnnotation.isLoading)
        XCTAssertNil(photoAnnotation.image)
    }

    func testShouldDownloadImageForPhotoAnnotationWhenThereIsAnImage() {
        let photoAnnotation = STPhotoMapSeeds().photoAnnotation()
        let request = STPhotoMapModels.PhotoAnnotationImageDownload.Request(photoAnnotation: photoAnnotation)
        self.sut.shouldDownloadImageForPhotoAnnotation(request: request)

        XCTAssertFalse(self.workerSpy.downloadImageForPhotoAnnotationCalled)
    }

    // MARK: - Caching geojson objects

    func testShouldCacheGeojsonObjectsWhenCacheIsEmptyForSuccessCase() {
        let tileCoordinates = STPhotoMapSeeds.tileCoordinates
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = tileCoordinates

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 0)
        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), tileCoordinates.count)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsEmptyForFailureCase() {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        self.sut.worker = worker

        let tileCoordinates = STPhotoMapSeeds.tileCoordinates
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = tileCoordinates

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertTrue(worker.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 0)
        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 0)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsNotEmptyForSuccessCase() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertFalse(self.workerSpy.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 1)
        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 0)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsNotEmptyForFailureCase() throws {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        self.sut.worker = worker

        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertFalse(worker.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 1)
        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 0)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsEmptyAndThereAreActiveDownloadsForSuccessCase() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl

        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.addActiveDownload(keyUrl)
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertFalse(self.workerSpy.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 0)
        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 1)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsEmptyAndThereAreActiveDownloadsForFailureCase() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl

        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.addActiveDownload(keyUrl)
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertFalse(self.workerSpy.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 0)
        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 1)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsNotEmptyAndThereAreActiveDownloadsForSuccessCase() throws {
        let tileCoordinates = STPhotoMapSeeds.tileCoordinates
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinates.first!).keyUrl
        let activeDownloadUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinates.last!).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()

        self.sut.cacheHandler.addActiveDownload(activeDownloadUrl)
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = tileCoordinates

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 2)
        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 1)
    }

    func testShouldCacheGeojsonObjectsWhenCacheIsNotEmptyAndThereAreActiveDownloadsForFailureCase() throws {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        self.sut.worker = worker

        let tileCoordinates = STPhotoMapSeeds.tileCoordinates
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinates.first!).keyUrl
        let activeDownloadUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinates.last!).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()

        self.sut.cacheHandler.addActiveDownload(activeDownloadUrl)
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = tileCoordinates

        self.waitForSynchronization()

        self.sut.shouldCacheGeojsonObjects()

        XCTAssertTrue(worker.getGeojsonTileForCachingCalled)

        XCTAssertEqual(self.sut.cacheHandler.cache.tileCount(), 1)
        XCTAssertEqual(self.sut.cacheHandler.activeDownloadCount(), 1)
    }

    // MARK: - Entity level

    func testShouldDetermineEntityLevelWhenCacheIsEmptyAndThereAreNoActiveDownloadsForSuccessCase() {
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenCacheIsEmptyAndThereAreNoActiveDownloadsForFailureCase() {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        self.sut.worker = worker

        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(worker.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenCacheIsEmptyAndThereAreActiveDownloads() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl

        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.addActiveDownload(keyUrl)
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertFalse(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenCacheIsNotEmptyAndNoActiveDownloads() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertFalse(self.workerSpy.getGeojsonTileForCachingCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenNewEntityLevelIsNotChanged() {
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.entityLevel = .city
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenNewEntityLevelIsChanged() {
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()

        self.sut.entityLevelHandler.entityLevel = .unknown
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
    }

    func testShouldDetermineEntityLevelWhenDownloadedTileIsNotStillVisible() {
        self.workerSpy.delay = self.workerDelay
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        self.waitForWorker(delay: self.workerDelay)

        self.sut.visibleTiles.removeAll()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentEntityLevelCalled)
        
        XCTAssertFalse(self.presenterSpy.presentRemoveCarouselCalled)
    }

    func testShouldDetermineEntityLevelWhenDownloadedTileIsStillVisible() {
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]

        self.waitForSynchronization()

        self.sut.shouldDetermineEntityLevel()

        XCTAssertTrue(self.workerSpy.getGeojsonTileForEntityLevelCalled)
        XCTAssertTrue(self.presenterSpy.presentEntityLevelCalled)
        
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
    }

    // MARK: - Location level

    func testShouldDetermineLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsNotEmptyAndEntityLevelIsNotLocation() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().locationGeojsonObject()

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .city

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAndThereAreActiveDownloads() throws {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.locationLevelHandler.addActiveDownload(keyUrl)

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertFalse(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsEmptyAndEntityLevelIsLocationAfterTileIsDownloadedForSuccessCase() {
        let tileCoordinate = STPhotoMapSeeds.tileCoordinate

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertTrue(self.presenterSpy.presentLocationAnnotationsCalled)
    }

    func testShouldDetermineLocationLevelWhenCacheIsEmptyAndEntityLevelIsNotLocationAfterTileDownload() {
        self.workerSpy.delay = self.workerDelay

        let tileCoordinate = STPhotoMapSeeds.tileCoordinate

        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.locationLevelHandler.removeAllActiveDownloads()
        self.sut.visibleTiles = [tileCoordinate]

        self.sut.entityLevelHandler.entityLevel = .location

        self.waitForSynchronization()

        self.sut.shouldDetermineLocationLevel()

        self.sut.entityLevelHandler.entityLevel = .city

        self.waitForWorker(delay: self.workerDelay)

        XCTAssertTrue(self.workerSpy.getGeojsonLocationLevelCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
    }
    
    func testShouldRemoveLocationAnnotationWhenEntityLevelIsNotLocation() {
        self.sut.cacheHandler.cache.removeAllTiles()
        self.sut.cacheHandler.removeAllActiveDownloads()
        
        self.sut.entityLevelHandler.entityLevel = .unknown
        self.sut.visibleTiles = [STPhotoMapSeeds.tileCoordinate]
        
        self.waitForSynchronization()
        
        self.sut.shouldDetermineEntityLevel()
        
        XCTAssertFalse(self.presenterSpy.presentLocationAnnotationsCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveLocationAnnotationsCalled)
    }
    
    // MARK: - Photo annotation selection
    
    func testShouldSelectPhotoAnnotationWhenItIsAlreadySelected() {
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        
        annotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForFailureCase() {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        worker.delay = self.workerDelay
        self.sut.worker = worker
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(worker.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelIsNotLocation() {
        self.sut.entityLevelHandler.entityLevel = .block
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertFalse(annotation.isSelected)
        XCTAssertTrue(previousAnnotation.isSelected)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldSelectPhotoAnnotationWhenItIsNotSelectedAndEntityLevelWillChangeForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoAnnotationSelection.Request(photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    // MARK: - Photo cluster annotation inflation
    
    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsMaximumAndThereAreOver15ClusterPhotos() {
        let zoomLevel = 20

        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 20)
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.presenterSpy.presentNavigateToSpecificPhotosCalled)
    }
    
    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsMaximumAndThereAreUnder15ClusterPhotosWithTheSameLocation() {
        self.workerSpy.delay = self.workerDelay
        let zoomLevel = 20

        let clusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        clusterAnnotation.interface = clusterAnnotationInterfaceSpy

        let previousClusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)
        previousClusterAnnotation.interface = previousClusterAnnotationInterfaceSpy

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.workerSpy.downloadImageForPhotoAnnotationCalled)

        XCTAssertTrue(previousClusterAnnotationInterfaceSpy.deflateCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.inflateCalled)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertTrue(value.isLoading)
            XCTAssertNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)

        self.waitForWorker(delay: self.workerDelay)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertFalse(value.isLoading)
            XCTAssertNotNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setImageCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)
    }

    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsNotMaximumAndThereAreUnder15ClusterPhotosWithTheSameLocation() {
        self.workerSpy.delay = self.workerDelay
        let zoomLevel = 17

        let clusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        clusterAnnotation.interface = clusterAnnotationInterfaceSpy

        let previousClusterAnnotationInterfaceSpy = MultiplePhotoClusterAnnotationInterfaceSpy()
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)
        previousClusterAnnotation.interface = previousClusterAnnotationInterfaceSpy

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.workerSpy.downloadImageForPhotoAnnotationCalled)

        XCTAssertTrue(previousClusterAnnotationInterfaceSpy.deflateCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.inflateCalled)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertTrue(value.isLoading)
            XCTAssertNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)

        self.waitForWorker(delay: self.workerDelay)

        clusterAnnotation.multipleAnnotationModels.forEach { (key, value) in
            XCTAssertFalse(value.isLoading)
            XCTAssertNotNil(value.image)
        }

        XCTAssertTrue(clusterAnnotationInterfaceSpy.setImageCalled)
        XCTAssertTrue(clusterAnnotationInterfaceSpy.setIsLoadingCalled)
    }

    func testShouldInflatePhotoClusterAnnotationWhenZoomLevelIsNotMaximumAndClusterPhotosWithDifferentLocation() {
        let zoomLevel = 17

        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10, sameCoordinate: false)
        let previousClusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 5)

        let request = STPhotoMapModels.PhotoClusterAnnotationInflation.Request(clusterAnnotation: clusterAnnotation, previousClusterAnnotation: previousClusterAnnotation, zoomLevel: zoomLevel)
        self.sut.shouldInflatePhotoClusterAnnotation(request: request)

        XCTAssertTrue(self.presenterSpy.presentZoomToCoordinateCalled)
    }
    
    // MARK: - Photo cluster annotation selection
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsAlreadySelected() {
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        annotation.isSelected = true
        
        let previousAnnotation = annotations.last!
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentNavigateToPhotoDetailsCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsLocationForFailureCase() {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        worker.delay = self.workerDelay
        self.sut.worker = worker
        
        self.sut.entityLevelHandler.entityLevel = .location
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(worker.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelIsNotLocation() {
        self.sut.entityLevelHandler.entityLevel = .block
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertFalse(annotation.isSelected)
        XCTAssertTrue(previousAnnotation.isSelected)
        
        XCTAssertFalse(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertFalse(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
    }
    
    func testShouldSelectPhotoClusterAnnotationWhenItIsNotSelectedAndEntityLevelWillChangeForSuccessCase() {
        self.sut.entityLevelHandler.entityLevel = .location
        self.workerSpy.delay = self.workerDelay
        
        let clusterAnnotation = STPhotoMapSeeds().multiplePhotoClusterAnnotation(count: 10)
        let annotations = STPhotoMapSeeds().photoAnnotations()
        let annotation = annotations.first!
        let previousAnnotation = annotations.last!
        previousAnnotation.isSelected = true
        
        let request = STPhotoMapModels.PhotoClusterAnnotationSelection.Request(clusterAnnotation: clusterAnnotation, photoAnnotation: annotation, previousPhotoAnnotation: previousAnnotation)
        self.sut.shouldSelectPhotoClusterAnnotation(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoClusterAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentDeselectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoAnnotationCalled)
        XCTAssertTrue(self.presenterSpy.presentSelectPhotoClusterAnnotationCalled)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getPhotoDetailsForPhotoAnnotationCalled)
        
        self.wait(delay: self.delay)
        
        self.sut.entityLevelHandler.entityLevel = .block
        
        XCTAssertFalse(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertFalse(self.presenterSpy.presentLocationOverlayCalled)
    }
    
    // MARK: - Carousel selection
    
    func testShouldSelectCarouselWhenCacheIsNotEmptyForSuccessCase() throws {
        self.workerSpy.delay = self.workerDelay
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsNotEmptyForFailureCase() throws {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        worker.delay = self.workerDelay
        self.sut.worker = worker
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(worker.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(worker.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsEmptyForSuccessCase() {
        self.workerSpy.delay = self.workerDelay
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeojsonCarouselSelectionOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeojsonTileForCarouselSelectionCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
                
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.getImageForPhotoCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldSelectCarouselWhenCacheIsEmptyForFailureCase() {
        let worker = STPhotoMapWorkerFailureSpy(delegate: self.sut)
        worker.delay = self.workerDelay
        self.sut.worker = worker
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let request = STPhotoMapModels.CarouselSelection.Request(tileCoordinate: tileCoordinate, location: STLocation.from(coordinate: coordinate))
        self.sut.shouldSelectCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(worker.cancelAllGeojsonCarouselSelectionOperationsCalled)
        XCTAssertTrue(worker.getGeojsonTileForCarouselSelectionCalled)
        
        self.waitForWorker(delay: self.workerDelay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
    }
    
    // MARK: - Carousel determination
    
    func testShouldDetermineCarouselWhenEntityLevelIsLocation() throws {
        self.sut.entityLevelHandler.entityLevel = .location
        
        self.workerSpy.delay = self.workerDelay
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        let request = STPhotoMapModels.CarouselDetermination.Request(mapRect: MKMapRect(origin: MKMapPoint(coordinate), size: MKMapSize.init(width: 1000, height: 1000)))
        self.sut.shouldDetermineCarousel(request: request)
        
        XCTAssertFalse(self.presenterSpy.presentNewCarouselCalled)
    }
    
    func testShouldDetermineCarouselWhenCacheIsNotEmptyForSuccessCase() throws {
        self.workerSpy.delay = self.workerDelay
        
        let coordinate = CLLocationCoordinate2D(latitude: 37.896175586962535, longitude: -122.5092990375)
        let tileCoordinate = TileCoordinate(coordinate: coordinate, zoom: 13)
        
        let keyUrl = STPhotoMapUrlBuilder().geojsonTileUrl(tileCoordinate: tileCoordinate).keyUrl
        let geojsonObject = try STPhotoMapSeeds().geojsonObject()
        
        self.sut.cacheHandler.removeAllActiveDownloads()
        self.sut.cacheHandler.cache.addTile(tile: STPhotoMapCache.Tile(keyUrl: keyUrl, geojsonObject: geojsonObject))
        self.sut.visibleTiles = [tileCoordinate]
        
        self.waitForSynchronization()
        
        let request = STPhotoMapModels.CarouselDetermination.Request(mapRect: MKMapRect(origin: MKMapPoint(coordinate), size: MKMapSize.init(width: 1000, height: 1000)))
        self.sut.shouldDetermineCarousel(request: request)
        
        XCTAssertTrue(self.presenterSpy.presentLoadingStateCalled)
        XCTAssertTrue(self.workerSpy.cancelAllGeoEntityOperationsCalled)
        XCTAssertTrue(self.workerSpy.getGeoEntityForEntityCalled)
        
        self.wait(delay: self.workerDelay + self.delay)
        
        XCTAssertTrue(self.presenterSpy.presentNotLoadingStateCalled)
        XCTAssertTrue(self.presenterSpy.presentRemoveCarouselCalled)
        XCTAssertTrue(self.presenterSpy.presentNewCarouselCalled)
    }
}
